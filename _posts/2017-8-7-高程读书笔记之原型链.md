---
layout:     post
title:      "高程读书笔记之原型链"
subtitle:   "对于原型链的认识"
date:       2017-08-07
author:     "cl"
header-img: "img/home-bg-o.jpg"
tags:
    - 前端开发
    - JavaScript
    - 翻译
---
# 前言
接下来一段时间我会就《JavaScript高级程序设计》这本书的阅读写一些读书笔记，主要目的是为了自己加深对一些重要概念的理解。那么今天主要写的是《高程》的第6章的内容。主要的难点与重点就是原型链，构造函数的编写和继承。

- [构造函数](#构造函数)
- [原型对象的问题](#原型对象的问题)
- [原型链](#原型链)
- [补充](#补充)
# 章节概述
众所周知JavaScript是一门面向对象的高级程序设计语言。有对象就有属性，JavaScript就包含两大属性：*数据属性*和*访问其属性*。这两个属性的主要区别就是————数据属性包含具体的值(对应属性：[value])。访问器属性包含两个重要方法:getter()和setter()(默认值为undefined)，顾名思义，这两个方法就是用来获取对象的属性值的。以上两大属性的共同属性包含【Configurable】(可否delete，默认为true)和【Enumable】(枚举属性)。 

## 构造函数
工厂模式:【基本思想】在函数内部创建一个实例并添加属性最终返回这个实例。代码如下：

    function createperson(name,age,job){
        var o=new Object();
        o.name=name;
        o.age=age;
        o.job=job;
        o.sayName=function(){
            alert(this.name);
        };
        return o;
    }

构造函数模式:【基本思想】将工厂模式中的实例改为this(PS:学习过C++等其它OOP的童鞋会比较熟悉)。代码如下：

    function Person(name,age,job){
        this.name=name;
        this.age=age;
        this.job=job;
        this.sayName=function(){
            alert(this.name);
        };
    }

原型模式：【基本思想】我们创建的每一个对象都包含一个属性prototype，这个属性指向person prototype(原型对象).person prototype包含constructor(构造函数属性)以及对象自己定义的一些属性。用对象创建的实例最终是指向原型对象的。（我的理解：在对象与实例之间创建一个公共的*原型对象*，在实例与对象之间建立了一种桥梁。弊端就是实例的属性值均会与person prototype一致,即共享性）。代码如下：

    function Person(){
    }
    Person.prototype={
        name="jackie";
        age=29;
        job=student;
        sayName=function(){
            alert(this.name);
        };
    }
    var person1=new Person();
    var person2=new Person();
    person1.name=Brenda;
    person1.sayName();//"Brenda"
    person2.sayName();//"jackie"


需要注意的是：

1. 在执行搜索时，采用向上搜索的原则 
2. 实例中创建的对象，若同名则会覆盖原型中的属性，但不会修改原属性。
3. 使用delete可以删除实例中的属性，从而让我们访问原型中的属性

检测属性：

hasOwnProperty()————存在与实例对象则返回true

## 原型对象的问题

共享性：因为没有为构造函数传递初始化参数，默认情况下，所有实例都将取得相同的属性值
解决办法————组合使用构造函数模式与原型模式

    //私有属性
    function Person(name,age,job){
        this.name=name;
        this.age=age;
        this.job=job;
        this.friends=["Jackie","Brenda"];
    }
    //公有属性（定义方法）
    Person.property={
        constructoe: Person,
        sayName=function(){
            alert(this.name);
        }
    }
    
    var person1=new Person("Jason",21,"FE");
    var person2=new Person("Linda",21,"Stu");
    person1.friends.push("Van");
    alert(person1.friends);//"Jackie,Brenda,Van"
    alert(person2.friends);//"Jackie,Brenda"
    alert(person1.friends===person2.friends);//false
    alert(person1.sayName===person2.sayName);//true

# 继承

## 原型链

基本模式：

    function SuperType(){
        this.property=true;
    }
    SuperType.prototype.getSuperValue=function(){
        return this.property;
    }
    function SubType(){
        this.property=false;
    }
    //继承SuperType
    SubType.prototype=new SuperType();
    SubType.prototype.getSubValue=function(){
        return this.subproperty;
    };
    var instance=new SubType();
    alert(instance.getSuperValue());//true

注意：添加与重写原型的方法必须在用SuperType的实例替换原型之后，再定义这两个方法。

解决问题（原型的共享性问题）：

    function SuperType(name){
        this.name=name;
        this.colors=["red","blue","green"];
    }

    SuperType.prototype.sayName=function(){
        alert(this.name);
    };
    function SubType(name,age){
        //继承属性
        SuperType.call(this,name);
        this.age=age;
    }
    //继承方法
    SubType.prototype=new SuperType();
    SubType.prototype.constructor=SubType;
    SubType.prototype.sayAge=function(){
        alert(this.age);
    };

    var instance1=new SubType("Jackie",21);
    instance1.colors.push("black");
    alert(instance1.colors);//red,blue,green,black
    instance1.sayName();//Jackie
    instance1.sayAge();//21

    var instance2=new SubType("Brenda",20);
    alert(instance2.colors);//red,blue,.green
    instance2.sayName();//Brenda
    instance2.sayAge();//20

## 补充: 

寄生模式在《高程（三）》中均有提及，这里未作详细说明，具体查看P160、P171