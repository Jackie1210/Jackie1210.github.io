---
layout:     post
title:      "[深入理解js]原型链"
subtitle:   "深入理解系列"
date:       2018-06-17
author:     "cl"
header-img: "img/home-bg-o.jpg"
tags:
    - js
---

## 前言
原型是js的构造函数中一个很重要的概念，而原型链的存在使得js可以向其他OOP语言一样有继承封装的存在。

## 准备工作
在正式开始理解原型链之前，我们假设大家已经明白了原型的概念，但是有这些还是不够的。我们还得对两个
重要的属性进行理解：<code>prototype</code>和<code> __proto__ </code>.

### prototype
我们知道当一个构造函数被创建的时候就会存在如下的这一个关系图：
![](/img/in-post/Prototype/instance1.png)
即，构造函数有一个prototype的属性只想自己的原型对象，原型对象也有一个constructor指向自己的构
造函数。

### __proto__
__proto__与prototype是截然不同的。

**__ptoto__才是形成原型链的关键，而不是prototype**
**__ptoto__才是形成原型链的关键，而不是prototype**
**__ptoto__才是形成原型链的关键，而不是prototype**

我们还是通过一张图来解释：
![](/img/in-post/Prototype/instance2.png)
图中，我们知道，clong是一个Person的实例，为了继承实例对象，就必须通过__proto__来继承。并且，通过
上图，我们可以知道 **__proto__是指向构造函数的原型对象的，而不是通过指向构造函数来间接指向原型
对象的。** 这一点特别重要，要牢记！

为了加深理解，不妨看看如下的等式是否与你想的一样：

```js
//prototype相关
typeof Number.prototype==="object"
typeof String.prototype==="object"
typeof Boolean.prototype==="object"
typeof Date.prototype==="object"
typeof Object.prototype==="object"
typeof Function.prototype==="function"//特殊
typeof JSON.prototype==="undefiend"//特殊

//__proto__相关
Object.__proto__===Function.prototype
Number.__proto__===Function.prototype
String.__proto__===Function.prototype
Boolean.__proto__===Function.prototype
Date.__proto__===Function.prototype
Function.__proto__===Function.prototype
JSON.__proto__===Object.prototype//特殊
```
## 正文
有了上面的对于prototype和__proto__的一些基本理解，我们接下来可以来看我们的原型链了。

### What
顾名思义，原型链就是由'原型'（__proto__）组成的链子。

### Why
js作为一门脚本语言，为了向java之类实现继承封装的效果，巧妙的利用了原型链来实现。既然是这样，讨论
原型链也就是讨论js继承的问题咯！下面，通过回顾js继承的发展来进一步理解原型链。

先来看一个栗子：
```js
function person(){
  this.name="person";
  this.favColor=[];
}
person.prototype.getname=function(){
  return this.name;
}
person.prototype.getFavColor=function(){
  return this.favColor;
}

person.prototype.setName=function(name){
  this.name=name;
}

function man(){
  this.sex="male";
}

man.prototype=new person();
let clong=new man();
let jackie=new man();
let lily=new man('lily');
console.log(clong.getname());//person
console.log(jackie.getname());//person
console.log(lily.getname());//person
console.log(clong.getFavColor());//[]
console.log(jackie.getFavColor());//[]
clong.name="clong"
clong.favColor.push('red');
console.log(clong.getname());//clong
console.log(jackie.getname());//person
console.log(clong.getFavColor());//['red']
console.log(jackie.getFavColor());//['red']

```
观察上面的的栗子，你是不是能够找到原型链存在的两个问题呢？不妨先思考一下，在看下去。

### 构造函数中基本类型的数据被实例修改不会共享，引用类型的属性被实例修改后会共享。
原因，我这里简单说一下，基本数据类型基本有<code>Number</code>、<code>String</code>、
<code>Boolean</code>、<code>Null</code>、<code>Undefiend</code>，这些类型的数据在内存
中是以栈存储的，创建了一个实例之后只是创建了父类的一个基本类型的浅拷贝，修改了这个值，并不会影响到
父类的属性。引用类型基本有Object，Array，Map，Set...，他们在内存中是以堆类型存储的，创建了
实例之后还创建了对父类的继承的属性的引用，所以实例修改了属性值就会反映到父类的属性当中。

### 子类创建实例的时候无法传递参数进去
具体看lily这个实例。

为了解决上面的两个问题，我们可以借助借用构造函数。

```js
function person(name){
  this.name=name;
  this.favColor=[];
}
person.prototype.getname=function(){
  return this.name;
}
person.prototype.getFavColor=function(){
  return this.favColor;
}

person.prototype.setName=function(name){
  this.name=name;
}

function man(name,age){
  person.call(this,name);
  this.sex="male";
  this.age=age;
}

//试着在自己的浏览器中打印看看
man.prototype=new person();
let clong=new man('clong',22);
let jackie=new man('jackie',21);
let lily=new man('lily',29);
console.log(clong.getname());
console.log(jackie.getname());
console.log(lily.getname());
console.log(clong.getFavColor());
console.log(jackie.getFavColor());
clong.name="clong"
clong.favColor.push('red');
console.log(clong.getname());
console.log(jackie.getname());
console.log(clong.getFavColor());
console.log(jackie.getFavColor());
```

## 寄生组合式继承
大家耳熟能详的应该就是以上的组合继承的方式了，不过这个继承还是有一定性能问题的。可以发现我们在子类
声明的时候和子类继承父类的时候分别调用了2次父类。那我们就想能不能只创建一次父类的实例。我们只需修改
一下下面这条语句：
```js
man.prototype=Object.create(person);
```
这里通过Object.create()创建了一个person的浅拷贝，从而实现了只调用了一次父类的实例就实现了继承。
## PS:
- <code>Object.prototype.__proto__===null</code>

## 参考资料
[最详尽的 JS 原型与原型链终极详解，没有「可能是」。](https://www.jianshu.com/p/dee9f8b14771)
《javascript高级程序设计》



