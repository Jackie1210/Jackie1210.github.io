---
layout:     post
title:      "[深入理解js]Closure"
subtitle:   "深入理解系列"
date:       2018-06-11
author:     "cl"
header-img: "img/home-bg-o.jpg"
catalog: true
tags:
    - js
---

## 为什么要写深入理解
笔者并不是大神，只是一个在校的大三学生。开始写深入理解系列是为了给js的一些重难点知识进行梳理，而不是每次面试之前都将这些知识重新理解一遍。事不宜迟，我们开始吧。

## 什么是闭包
闭包是函数！（废话）闭包还是一个可以访问函数中变量的函数。
```js
function who(){
  let name='clong';
  function print(){
    return name;
  }
  return print;
}
let boy=who();
let myName=boy();
console.log(myName);//'clong'
```
开始的定义可能会令你感觉晦涩难懂，看了上面的例子我们一起来理解一下。

### 分析
下面我们来分析一下上面的栗子。

- 首先我们声明了一个函数，这个函数包含了一个变量name和一个print函数，执行到return print的时候进行返回。
- 紧接着我们在全局作用域下生命了一个变量boy，继续向该行后面看，有个who，接着我们遇到（）,这时我们就会重新返回到上面查找who有没有声明。
- 进入who体内，我们声明了一个变量name并赋值为clong，然后申明了一个print函数，接着我们返回print，此时print函数被销毁，而boy保存着print函数的引用。
- 接着我们遇到myName,基本流程与上面的boy是差不多一致的，只不过这时我们的myName不是保存着一个函数，而是保存了name的值(注意：这里name已经被销毁了，不信你可以在全局作用域下打印name的值看看！)。

有了上面的栗子，我们来看看下面这个栗子：

```js
function createCounter() {
  let counter = 0
  const myFunction = function() {
      counter = counter + 1
      return counter
    }
    return myFunction
  }
  const increment = createCounter()
  const c1 = increment()
  const c2 = increment()
  const c3 = increment()
  console.log('example increment', c1, c2, c3)//1,2,3
```
思考一下，答案与你认为的一样吗？是不是以为是1，1，1呢？先不要急，我们再来看看下面这个栗子。

```js
var makeCounter = function() {
  var privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  }  
};

var Counter1 = makeCounter();
var Counter2 = makeCounter();
console.log(Counter1===Counter2);
console.log(Counter1.value()); /* logs 0 */
Counter1.increment();
Counter1.increment();
console.log(Counter1.value()); /* logs 2 */
Counter1.decrement();
console.log(Counter1.value()); /* logs 1 */
console.log(Counter2.value()); /* logs 0 */
```

看看上面的栗子，你会不会疑惑？本质上都是调用的私有函数的方法，为什么Counter1和Counter2的privateCounter就会完全不一样呢？

笔者查看了很多资料，别人总结的要么就是将mdn上的解释一贴，要么就是含糊其辞。

> 请注意两个计数器 counter1 和 counter2 是如何维护它们各自的独立性的。每个闭包都是引用自己词法作用域内的变量 privateCounter 。每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境。然而在一个闭包内对变量的修改，不会影响到另外一个闭包中的变量。————MDN

那么为什么对一个闭包的变量的改变不会影响到另一个闭包中的变量呢？我思考了很久，最后这样解释给自己听：

前一个栗子中，我们的increment保存的是myFunction的引用和他的闭包（important：函数在创建的时候就会形成自己的作用域链）。了解过闭包的应该都有保存在内存中这个概念，那么我们这里没得操作都是直接对闭包的操作，价值作用域的执行顺序（闭包=>父级=>...）,每次都是从闭包中获取，并且将修改的值保存在内存中，自然是1，2，3!

那么后面一个栗子呢？我先姑且解释看看（有不对的希望大牛可以指出）,函数中的变量都是私有的（包括函数），第二个栗子返回的是一个对象，然后我们后面的操作都是基于这个对象的属性的操作，间接操作了内部的私有方法并获取了内部的值。那么，回想一下new一个对象发生了什么？
- 创建一个空对象
- 将构造函数的作用域赋给新对象，即将this只想新对象
- 讲原型中的属性添加到这个对象当中
- 返回新对象
这个栗子不是正好跟上面的操作类似吗？如果还是不明白，我们假设makeCounter是一个Array对象，里面的private和changeBy是length和push内部实现原理，返回一个新对象，并且给了你一些接口，而这个接口正好有push，使你可以进行push操作，且仅限于该对象的私有属性的方式。那么实例与实例的私有属性或方法共有吗？当然不！神奇的利用闭包就实现了数据的私有和封装了

## 用处
经过了上面的分析，我们大概可以了解到闭包的一些用处了吧。
- 访问函数中的变量
- 函数属性的私有化/封装（PS：这一块还涉及到原型链，下次再写）

## 劣势
这些也是耳熟能详了！
- 性能问题，一直暴露在内存当中，无法被垃圾回收机制回收，很有可能造成内存泄漏！

## 场景
- 回调函数
- 页面交互操作（同上！）
- setTimeout（不也是回调函数嘛！）
- 数据私有和封装
## tips
- 仍然可以访问外部函数的中定义的变量即使外部函数被返回了
- 闭包存储对外部函数中变量的引用，而不是值
- 闭包可以实现js的数据的封装和私有化
## 参考资料
[MDN/JS/闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)
[Understand JavaScript Closures With Ease](http://javascriptissexy.com/understand-javascript-closures-with-ease/)
[I never understood JavaScript closures](https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8)



[博客地址](https://jackie1210.github.io)

